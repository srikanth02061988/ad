import streamlit as st
import pdfplumber
from langchain.text_splitter import RecursiveCharacterTextSplitter
import psycopg2
from psycopg2.extras import execute_values
import numpy as np
import logging
import requests
import json
import uuid
from openai import AzureOpenAI
from io import BytesIO
from reportlab.lib.pagesizes import letter
from reportlab.pdfgen import canvas
from reportlab.lib.units import inch

# Initialize logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# Azure OpenAI client initialization
try:
    client = AzureOpenAI(
        api_version="2024-02-01",
        azure_endpoint="https://effopenai.openai.azure.com/",
        api_key="7896c56d537df41980034ac85b9d9bc9"
    )
    logger.info("Azure OpenAI client initialized successfully.")
except Exception as e:
    logger.error(f"Failed to initialize Azure OpenAI client: {e}")

# Azure and database configuration
azure_endpoint = "https://effopenai.openai.azure.com"
azure_api_key = "7896c56d537df41980034ac85b9d9bc9"
embedding_deployment = "TEB-Robin"
completion_deployment = "ajitTest"

headers = {
    "Content-Type": "application/json",
    "api-key": azure_api_key
}

def get_embeddings(text, endpoint, headers, deployment=embedding_deployment):
    try:
        logger.info("Generating embeddings...")
        url = f"{endpoint.strip()}/openai/deployments/{deployment}/embeddings?api-version=2024-02-15-preview"
        data = {"input": text}
        response = requests.post(url, headers=headers, json=data)
        response.raise_for_status()
        result = response.json()
        embedding = result['data'][0]['embedding']
        logger.info("Embeddings generated successfully.")
        return embedding
    except requests.exceptions.RequestException as e:
        logger.error(f"An error occurred while generating embeddings: {e}")
        st.error(f"An error occurred while generating embeddings: {e}")
        return None

def get_pdf_text(pdf_docs):
    text = ""
    try:
        with pdfplumber.open(pdf_docs) as pdf:
            for page in pdf.pages:
                page_text = page.extract_text()
                if page_text:
                    cleaned_text = page_text.replace('\x00', '')
                    text += cleaned_text
        logger.info("Text extracted from PDF successfully.")
    except Exception as e:
        logger.error(f"An error occurred while extracting text from PDF: {e}")
        st.error(f"An error occurred while extracting text from PDF: {e}")
    return text

def get_text_chunks(text):
    logger.info("Splitting text into chunks...")
    text_splitter = RecursiveCharacterTextSplitter(chunk_size=5000, chunk_overlap=500)
    chunks = text_splitter.split_text(text)
    logger.info(f"Text split into {len(chunks)} chunks.")
    return chunks

def store_embeddings_in_db(pdf_id, text_chunks, endpoint, headers):
    try:
        logger.info("Connecting to PostgreSQL database...")
        conn = psycopg2.connect(
            host="npceffepsql.postgres.database.azure.com",
            port="5432",
            database="Digital_marketing_Embeddings",
            user="pgadmin",
            password="npceeff8kS"
        )
        with conn.cursor() as cur:
            cur.execute("""
            CREATE TABLE IF NOT EXISTS embeddings (
                id BIGSERIAL PRIMARY KEY,
                pdf_id UUID,
                content TEXT,
                embedding VECTOR(1536)
            )
            """)
            conn.commit()
            logger.info("Table checked/created successfully.")

        embeddings = []
        for chunk in text_chunks:
            embedding = get_embeddings(chunk, endpoint, headers)
            if embedding is not None:
                embedding_vector = np.array(embedding, dtype=np.float32)
                embeddings.append((pdf_id, chunk, embedding_vector.tolist()))
            else:
                logger.warning("Embedding generation returned None.")

        if embeddings:
            with conn.cursor() as cur:
                execute_values(cur, "INSERT INTO embeddings (pdf_id, content, embedding) VALUES %s", embeddings)
                conn.commit()
            logger.info("Embeddings stored in the database successfully.")
        conn.close()
    except Exception as e:
        logger.error(f"An error occurred while storing embeddings in the database: {e}")
        st.error(f"An error occurred while storing embeddings in the database: {e}")

def retrieve_embeddings_from_db(pdf_id):
    try:
        logger.info("Retrieving embeddings from the database...")
        conn = psycopg2.connect(
            host="npceffepsql.postgres.database.azure.com",
            port="5432",
            database="Digital_marketing_Embeddings",
            user="pgadmin",
            password="npceeff8kS"
        )
        with conn.cursor() as cur:
            cur.execute("SELECT content, embedding::text FROM embeddings WHERE pdf_id = %s", (pdf_id,))
            rows = cur.fetchall()
        conn.close()

        if rows:
            docs = [row[0] for row in rows]
            embeddings = np.array([np.fromstring(row[1][1:-1], sep=',') for row in rows], dtype=np.float32)
            logger.info("Embeddings retrieved successfully.")
            return docs, embeddings
        else:
            logger.warning("No embeddings found for the given PDF ID.")
            return None, None
    except Exception as e:
        logger.error(f"An error occurred while retrieving embeddings from the database: {e}")
        st.error(f"An error occurred while retrieving embeddings from the database: {e}")
        return None, None

def find_relevant_chunks(question, docs, embeddings, top_k=5):
    return docs[:top_k]

def generate_responses(question, relevant_docs, client, deployment="ajitTest", num_responses=3):
    try:
        combined_docs = "\n\n".join(relevant_docs)
        prompt = f"Based on the following documents, answer the question: {question}\n\nDocuments:\n\n{combined_docs}"

        responses = []
        for _ in range(num_responses):
            response = client.chat.completions.create(
                model=deployment,
                messages=[
                    {"role": "system", "content": "Assistant is a large language model trained by OpenAI."},
                    {"role": "user", "content": prompt}
                ]
            )
            text_response = response.choices[0].message.content.strip()
            responses.append(text_response)
        logger.info("Responses generated successfully.")
        return responses
    except Exception as e:
        logger.error(f"An error occurred while generating responses: {e}")
        st.error(f"An error occurred while generating responses: {e}")
        return []

def create_pdf(text_response, category):
    buffer = BytesIO()
    p = canvas.Canvas(buffer, pagesize=letter)
    
    # Draw text response
    text_object = p.beginText(40, 700)
    text_object.setFont("Helvetica", 12)
    max_width = 7.5 * inch
    lines = text_response.split('\n')
    for line in lines:
        while len(line) > 0:
            part = line[:int(max_width / 6)]
            text_object.textLine(part)
            line = line[int(max_width / 6):]
    p.drawText(text_object)

    p.showPage()
    p.save()
    buffer.seek(0)
    return buffer, f"{category}.pdf"

def image(src_as_string, **style):
    return img(src=src_as_string, style=styles(**style))

def link(link, text, **style):
    return a(_href=link, _target="_blank", style=styles(**style))(text)

def layout(*args):

    style = """
    <style>
      #MainMenu {visibility: hidden;}
      footer {visibility: hidden;}
      .stApp { bottom: 105px; }
    </style>
    """

    body = p()
    foot = div(
        style="""
            width: calc(100% - 15rem); 
            margin-left: 15rem;
            background-color: #0D2A50;
            color: white;
            text-align: center;
            padding: 10px;
        """
    )(
        hr(
            style="""
                display: block;
                margin: 8px auto;
                border-style: inset;
                border-width: 2px;
            """
        ),
        body
    )

    st.markdown(style, unsafe_allow_html=True)

    for arg in args:
        if isinstance(arg, str):
            body(arg)
        elif isinstance(arg, HtmlElement):
            body(arg)

    st.markdown(str(foot), unsafe_allow_html=True)

def footer():
    myargs = [
        "2024 State Street Corporation. All rights reserved.",
        br(),
        "By accessing this website, you agree to be bound by the terms and conditions that appear herein.",
        br(),
        "These terms and conditions are subject to change. State Street reserves the right to modify these terms and conditions, which it may do by posting changes to the website.",
        br(),
        "If you do not agree with these terms and conditions, please do not access the website.",
        br(),
        link("#", "Global Privacy Notice"),
        " | ",
        link("#", "Cookie Settings"),
        " | ",
        link("#", "Cookie Disclosure"),
        " | ",
        link("#", "Legal"),
        " | ",
        link("#", "Sitemap")
    ]
    layout(*myargs)

def header():
    st.markdown(
        """
        <style>
        .custom-header {
            background-color: #002855;
            color: white;
            padding: 10px;
            text-align: left;
            font-size: 20px;
            width: calc(100% - 15rem);
            margin-left: 15rem;
            position: relative;
            top: 0;
            z-index: 1000;
        }
        .custom-header a {
            color: white;
            margin-right: 15px;
        }
        .custom-header .header-right {
            float: right;
        }
        </style>
        <div class="custom-header">
            United States - Asset Manager
            <div class="header-right">
                <a href="https://www.statestreet.com/contact-us.html">Contact Us</a>
                <a href="https://www.statestreet.com/company-websites.html">Company Websites</a>
            </div>
        </div>
        """,
        unsafe_allow_html=True
    )

def main():
    logger.info("Setting up the Streamlit page...")
    st.set_page_config(page_title="Derived content uc generator app")

    # Add the top header
    header()

    # Add header image and application name
    header_image_url = "https://your-image-url.com/header.png"  # Update this URL to your header image
    st.markdown(f"""
    <div style='display: flex; align-items: center; margin-top: 60px;'>  <!-- Add margin-top to avoid overlap with fixed header -->
        <img src='{header_image_url}' style='width: 50px; margin-right: 10px;'>
        <h1 style='margin: 0; font-size: 24px;'>Digital Marketing Derived Content Generator</h1>
    </div>
    """, unsafe_allow_html=True)

    st.sidebar.title("Menu")

    tab1, tab2 = st.tabs(["Upload & Generate", "Developer Prompt"])

    if "pdf_id" not in st.session_state:
        st.session_state.pdf_id = None

    if "text_chunks" not in st.session_state:
        st.session_state.text_chunks = []

    if "responses_tab1" not in st.session_state:
        st.session_state.responses_tab1 = []

    if "responses_tab2" not in st.session_state:
        st.session_state.responses_tab2 = []

    if "selected_response_tab1" not in st.session_state:
        st.session_state.selected_response_tab1 = None

    if "selected_response_tab2" not in st.session_state:
        st.session_state.selected_response_tab2 = None

    if "category_selected" not in st.session_state:
        st.session_state.category_selected = None

    if "regenerate_count" not in st.session_state:
        st.session_state.regenerate_count = 0

    with tab1:
        pdf_docs = st.sidebar.file_uploader("Upload your PDF Files", type=["pdf"], key="pdf_upload_tab1")

        if pdf_docs is not None and st.sidebar.button("Submit PDF", key="submit_pdf_tab1"):
            with st.spinner("Processing..."):
                raw_text = get_pdf_text(pdf_docs)
                if raw_text:
                    text_chunks = get_text_chunks(raw_text)
                    pdf_id = str(uuid.uuid4())
                    store_embeddings_in_db(pdf_id, text_chunks, azure_endpoint, headers)
                    st.session_state.pdf_id = pdf_id
                    st.session_state.text_chunks = text_chunks
                    st.sidebar.success("PDF processed and embeddings stored.")
                else:
                    logger.warning("No text extracted from PDF.")
                    st.error("Failed to extract text from the uploaded PDF.")

        if st.session_state.pdf_id:
            category = st.selectbox("Select the category to search within:", ["Twitter", "LinkedIn", "Asset Intelligence", "Article Card", "Other"], key="category_tab1")
            if st.button("Generate" if st.session_state.regenerate_count == 0 else "Regenerate", key="generate_button_tab1"):
                if st.session_state.category_selected != category:
                    st.session_state.regenerate_count = 0
                with open(f"prompts{st.session_state.regenerate_count}.json", "r") as file:
                    try:
                        prompts = json.load(file)
                        logger.info("Prompts loaded successfully.")
                    except json.JSONDecodeError:
                        logger.error("Error loading prompts from JSON.")
                        st.error("Error loading prompts. Please check the prompts.json file.")
                        return
                system_prompt = prompts.get(category, "Default prompt")
                text_chunks = st.session_state.get("text_chunks", [])
                responses = generate_responses(system_prompt, text_chunks, client)
                if responses:
                    st.session_state.responses_tab1 = responses
                    st.session_state.category_selected = category
                    st.session_state.regenerate_count = (st.session_state.regenerate_count + 1) % 3

        if st.session_state.responses_tab1:
            st.write("Responses:")
            selected_response = st.radio("Select a response to download:", st.session_state.responses_tab1, key="responses_radio_tab1")
            st.session_state.selected_response_tab1 = selected_response

            if st.session_state.selected_response_tab1:
                st.write("Selected Response:")
                st.write(st.session_state.selected_response_tab1)
                pdf_buffer, pdf_filename = create_pdf(st.session_state.selected_response_tab1, st.session_state.category_selected)
                st.download_button(
                    "Download Selected Response as PDF",
                    data=pdf_buffer,
                    file_name=pdf_filename,
                    mime="application/pdf",
                    key="download_button_tab1"
                )

    with tab2:
        if st.session_state.pdf_id:
            user_question = st.text_area("Ask a Question based on the uploaded PDF", height=200, key="question_tab2")
            if st.button("Submit", key="submit_tab2"):
                with st.spinner("Retrieving and processing..."):
                    pdf_id = st.session_state.pdf_id
                    docs, embeddings = retrieve_embeddings_from_db(pdf_id)
                    if docs and embeddings is not None and embeddings.any():
                        relevant_docs = find_relevant_chunks(user_question, docs, embeddings)
                        responses = generate_responses(user_question, relevant_docs, client)
                        if responses:
                            st.session_state.responses_tab2 = responses

        if st.session_state.responses_tab2:
            st.write("Responses:")
            selected_response = st.radio("Select a response to download:", st.session_state.responses_tab2, key="responses_radio_tab2")
            st.session_state.selected_response_tab2 = selected_response

            if st.session_state.selected_response_tab2:
                st.write("Selected Response:")
                st.write(st.session_state.selected_response_tab2)
                pdf_buffer, pdf_filename = create_pdf(st.session_state.selected_response_tab2, "developer_prompt")
                st.download_button(
                    "Download Selected Response as PDF",
                    data=pdf_buffer,
                    file_name=pdf_filename,
                    mime="application/pdf",
                    key="download_button_tab2"
                )

    footer()

if __name__ == "__main__":
    main()

